FastAPI usefully
...
@app.get("/sm/{sm_id}")
async def read_sm(sm_id):
	return ("sm_id": sm_id)
input - http://localhost:8000/sm/eat
answer - {"sm_id": "eat"}
Also you can write
...
async def read_number(number: int):
	...
if you'll write string or float you'll give valid error
This example shows how to use parameters:
from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()
@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    if model_name == ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}

You can also write to file path using this code:
...
@app.get("files/{file_path:path}")
async def read_file(file_path: str):
        return {"file_path": file_path}


Query Parameters you can write after ? and you can use & for the next paramater.
Next code shows how to use parameters:
...
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


@app.get("/items/")
async def read_item(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]


Of course you can write difault = None.
For example:
...
@app.get("/items/{item_id}")
async def read_item(item_id: str, q: str | None = None):
    if q:
        return {"item_id": item_id, "q": q}
    return {"item_id": item_id}
In the last example item_id is required, and it is path. And q is parameters ans defaukt = None.


You can also declare bool types, and they will be converted:
...
@app.get("/items/{item_id}")
async def read_item(item_id: str, q: str | None = None, short: bool = False):
    item = {"item_id": item_id}
    if q:
        item.update({"q": q})
    if not short:
        item.update(
            {"description": "This is an amazing item that has a long description"}
        )
    return item
The method update - update dict item.
You can write the short parameter like true, True, 1, on, yes. These values will be validate.


The next example shows how to work with path parameters and query parameters:
...
@app.get("/users/{user_id}/items/{item_id}")
async def read_user_item(
    user_id: int, item_id: str, q: str | None = None, short: bool = False
):
    item = {"item_id": item_id, "owner_id": user_id}
    if q:
        item.update({"q": q})
    if not short:
        item.update(
            {"description": "This is an amazing item that has a long description"}
        )
    return item

If you want to make query parameter is required you can not to write additional parameters.
For example:
...
@app.get("/items/{item_id}")
async def read_user_item(item_id: str, needy: str):
    item = {"item_id": item_id, "needy": needy}
    return item

You also can make class for models.
For example:
from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

You can use attributes of your models class.
...
app.post("/items/")
async def create_item(item: Item):
    item_dict = item.dict()
    if item.tax:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

You can also use models ans path parameters.
...
@app.put("/items/{item_id}")
async def create_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}


You can also use query parameters for looking a leight.
For example:
from fastapi import FastAPI, Query
...
@app.get("/items/")
async def read_items(q: str | None = Query(default=None, max_length=50)):
	...
q: str | None = Query(default=None)

In FastAPI you can use regular expressions without import re.
You can write min_length, max_length:
...
async def read_items(q: str = Query(min_length=3)):
	...

You can another way to make query parameter is required.
For this aim you should use ...
...
@app.get("/items/")
async def read_items(q: str = Query(default=..., min_length=3)):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results
You also can make it with this code:
...
from pydantic import Required
...
async def read_items(q: str = Query(default=Required, min_length=3)):
	...

You can write query parameters like a list.
For example:
...
async def read_items(q: list[str] | None = Query(default=None)):
    query_items = {"q": q}
    return query_items

You can add title and description in the query parameters.
...
async def read_items(
    q: str
    | None = Query(
        default=None,
        title="Query string",
        description="Query string for the items to search in the database that have a good match",
        min_length=3,
    )
):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results

If you want to make a query parameter "item-query" or so-so. You can use this code:
...
async def read_items(q: str | None = Query(default=None, alias="item-query")):
	...


